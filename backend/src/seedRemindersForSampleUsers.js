const Parse = require('parse/node');
require('dotenv').config();

// Parse Server Configuration
const APP_ID = process.env.PARSE_APP_ID || 'hearing-clinic-app-id';
const MASTER_KEY = process.env.PARSE_MASTER_KEY || 'your-master-key-change-this';
const DATABASE_URI = process.env.DATABASE_URI || 'mongodb://mongo:27017/hearing-clinic-db';
const isInsideDocker = require('fs').existsSync('/.dockerenv');
const SERVER_URL = process.env.PARSE_SERVER_URL || 
  (isInsideDocker ? 'http://localhost:1337/parse' : 'http://localhost:1338/parse');

// Initialize Parse
Parse.initialize(APP_ID);
Parse.serverURL = SERVER_URL;
Parse.masterKey = MASTER_KEY;

/**
 * Helper function to create a reminder
 */
async function createReminder(data) {
  const Reminder = Parse.Object.extend('Reminder');
  const reminder = new Reminder();
  
  // Set client - use it directly (it should be a Parse Object already)
  if (data.client) {
    // If it's already a Parse Object, use directly; otherwise create pointer
    if (data.client instanceof Parse.Object) {
      reminder.set('client', data.client);
    } else if (typeof data.client === 'string') {
      reminder.set('client', Parse.Object.createWithoutData('Client', data.client));
    } else {
      reminder.set('client', data.client);
    }
  }
  
  reminder.set('title', data.title);
  if (data.description) reminder.set('description', data.description);
  reminder.set('dueAt', data.dueAt);
  reminder.set('status', data.status || 'pending');
  if (data.type) reminder.set('type', data.type);
  if (data.priority) reminder.set('priority', data.priority);
  
  // Handle appointmentId pointer
  if (data.appointmentId) {
    if (typeof data.appointmentId === 'object' && data.appointmentId.id) {
      reminder.set('appointmentId', Parse.Object.createWithoutData('Appointment', data.appointmentId.id));
    } else {
      reminder.set('appointmentId', data.appointmentId);
    }
  }
  
  // Handle hearingReportId pointer
  if (data.hearingReportId) {
    if (typeof data.hearingReportId === 'object' && data.hearingReportId.id) {
      reminder.set('hearingReportId', Parse.Object.createWithoutData('HearingReport', data.hearingReportId.id));
    } else {
      reminder.set('hearingReportId', data.hearingReportId);
    }
  }
  
  if (data.isAutoGenerated !== undefined) reminder.set('isAutoGenerated', data.isAutoGenerated);
  if (data.autoRecurring !== undefined) reminder.set('autoRecurring', data.autoRecurring);
  if (data.recurringInterval) reminder.set('recurringInterval', data.recurringInterval);
  
  // Handle createdBy/updatedBy pointers - only set if valid
  if (data.createdBy) {
    let userId = null;
    if (typeof data.createdBy === 'object') {
      userId = data.createdBy.id || data.createdBy.objectId || data.createdBy._id;
    } else {
      userId = data.createdBy;
    }
    if (userId) {
      reminder.set('createdBy', Parse.Object.createWithoutData('_User', userId));
    }
  }
  if (data.updatedBy) {
    let userId = null;
    if (typeof data.updatedBy === 'object') {
      userId = data.updatedBy.id || data.updatedBy.objectId || data.updatedBy._id;
    } else {
      userId = data.updatedBy;
    }
    if (userId) {
      reminder.set('updatedBy', Parse.Object.createWithoutData('_User', userId));
    }
  }
  
  return await reminder.save(null, { useMasterKey: true });
}

/**
 * Check if reminder already exists for this appointment and type
 */
async function reminderExists(appointmentId, type) {
  const Reminder = Parse.Object.extend('Reminder');
  const query = new Parse.Query(Reminder);
  query.equalTo('appointmentId', Parse.Object.createWithoutData('Appointment', appointmentId));
  query.equalTo('type', type);
  const count = await query.count({ useMasterKey: true });
  return count > 0;
}

/**
 * Create reminders for a completed appointment
 */
async function createRemindersForAppointment(appointment, adminUser) {
  const appointmentType = appointment.get('type');
  const status = appointment.get('status');
  const appointmentDate = appointment.get('date');
  const appointmentClient = appointment.get('client');
  const createdBy = appointment.get('createdBy') || adminUser;

  // Only create reminders for COMPLETED appointments
  if (status !== 'COMPLETED' || !appointmentClient || !appointmentDate) {
    return [];
  }

  const reminders = [];
  const apptDate = new Date(appointmentDate);
  
  // Get client ID and create pointer
  let clientId;
  if (typeof appointmentClient === 'object') {
    clientId = appointmentClient.id || appointmentClient.objectId || appointmentClient._id;
    if (!clientId) {
      console.error('Cannot get client ID from appointment');
      return [];
    }
  } else {
    clientId = appointmentClient;
  }
  
  if (!clientId) {
    console.error('Client ID is missing');
    return [];
  }
  
  // Fetch client to get fullName
  let clientFullName = '';
  try {
    const Client = Parse.Object.extend('Client');
    const clientObj = await (new Parse.Query(Client).get(clientId, { useMasterKey: true }));
    clientFullName = clientObj.get('fullName') || '';
  } catch (error) {
    console.error(`Error fetching client ${clientId}: ${error.message}`);
  }
  
  const clientPtr = Parse.Object.createWithoutData('Client', clientId);

  if (appointmentType === 'REPAIR') {
    // 1. Ki·ªÉm tra sau s·ª≠a (2 tu·∫ßn)
    const checkupDate = new Date(apptDate);
    checkupDate.setDate(checkupDate.getDate() + 14);
    
    const checkupExists = await reminderExists(appointment.id, 'POST_REPAIR_CHECK');
    if (!checkupExists) {
      const reminder = await createReminder({
        client: client,
        title: `Ki·ªÉm tra sau s·ª≠a m√°y - ${clientFullName}`,
        description: 'Ki·ªÉm tra m√°y tr·ª£ th√≠nh sau khi s·ª≠a ƒë·ªÉ ƒë·∫£m b·∫£o ho·∫°t ƒë·ªông t·ªët.',
        dueAt: checkupDate,
        status: checkupDate < new Date() ? 'overdue' : 'pending',
        type: 'POST_REPAIR_CHECK',
        priority: 'medium',
        appointmentId: appointment,
        isAutoGenerated: true,
        createdBy: createdBy,
        updatedBy: createdBy,
      });
      reminders.push(reminder);
    }

    // 2. B·∫£o tr√¨ ƒë·ªãnh k·ª≥ (6 th√°ng)
    const maintenanceDate = new Date(apptDate);
    maintenanceDate.setMonth(maintenanceDate.getMonth() + 6);
    
    const maintenanceExists = await reminderExists(appointment.id, 'MAINTENANCE_DUE');
    if (!maintenanceExists) {
      const reminder = await createReminder({
        client: client,
        title: `B·∫£o tr√¨ ƒë·ªãnh k·ª≥ m√°y tr·ª£ th√≠nh - ${clientFullName}`,
        description: 'Nh·∫Øc nh·ªü b·∫£o tr√¨ ƒë·ªãnh k·ª≥ m√°y tr·ª£ th√≠nh sau 6 th√°ng.',
        dueAt: maintenanceDate,
        status: maintenanceDate < new Date() ? 'overdue' : 'pending',
        type: 'MAINTENANCE_DUE',
        priority: 'medium',
        appointmentId: appointment,
        isAutoGenerated: true,
        autoRecurring: true,
        recurringInterval: 180, // 6 th√°ng
        createdBy: createdBy,
        updatedBy: createdBy,
      });
      reminders.push(reminder);
    }

  } else if (appointmentType === 'PURCHASE') {
    // H·ªó tr·ª£ sau mua: 1 tu·∫ßn, 1 th√°ng, 3 th√°ng
    const intervals = [
      { days: 7, title: 'H·ªó tr·ª£ sau mua (1 tu·∫ßn)', description: 'Li√™n h·ªá kh√°ch h√†ng sau 1 tu·∫ßn ƒë·ªÉ h·ªó tr·ª£ v√† ƒëi·ªÅu ch·ªânh m√°y tr·ª£ th√≠nh.', type: 'POST_PURCHASE_SUPPORT' },
      { days: 30, title: 'H·ªó tr·ª£ sau mua (1 th√°ng)', description: 'Theo d√µi t√¨nh tr·∫°ng s·ª≠ d·ª•ng m√°y tr·ª£ th√≠nh sau 1 th√°ng.', type: 'POST_PURCHASE_SUPPORT' },
      { days: 90, title: 'H·ªó tr·ª£ sau mua (3 th√°ng)', description: 'ƒê√°nh gi√° hi·ªáu qu·∫£ s·ª≠ d·ª•ng m√°y tr·ª£ th√≠nh sau 3 th√°ng.', type: 'POST_PURCHASE_SUPPORT' },
    ];

    for (const interval of intervals) {
      const dueDate = new Date(apptDate);
      dueDate.setDate(dueDate.getDate() + interval.days);
      
      // Check if reminder already exists (we'll use a combination of type and days)
      const existingQuery = new Parse.Query(Parse.Object.extend('Reminder'));
      existingQuery.equalTo('appointmentId', appointment);
      existingQuery.equalTo('type', interval.type);
      existingQuery.equalTo('title', `${interval.title} - ${clientFullName}`);
      const exists = await existingQuery.count({ useMasterKey: true }) > 0;
      
      if (!exists) {
        const reminder = await createReminder({
          client: client,
          title: `${interval.title} - ${clientFullName}`,
          description: interval.description,
          dueAt: dueDate,
          status: dueDate < new Date() ? 'overdue' : 'pending',
          type: interval.type,
          priority: interval.days === 7 ? 'high' : 'medium',
          appointmentId: appointment,
          isAutoGenerated: true,
          createdBy: createdBy,
          updatedBy: createdBy,
        });
        reminders.push(reminder);
      }
    }

  } else if (appointmentType === 'AUDIOGRAM') {
    // ƒêo th√≠nh l·ª±c ƒë·ªãnh k·ª≥ ti·∫øp theo (6-12 th√°ng)
    const hearingReport = appointment.get('hearingReport');
    let nextAudiogramDate = new Date(apptDate);
    nextAudiogramDate.setMonth(nextAudiogramDate.getMonth() + 6); // M·∫∑c ƒë·ªãnh 6 th√°ng
    
    // C√≥ th·ªÉ ƒëi·ªÅu ch·ªânh d·ª±a tr√™n recommendations trong hearing report
    if (hearingReport) {
      try {
        await hearingReport.fetch({ useMasterKey: true });
        const recommendations = hearingReport.get('recommendations');
        if (recommendations && recommendations.toLowerCase().includes('3 th√°ng')) {
          nextAudiogramDate = new Date(apptDate);
          nextAudiogramDate.setMonth(nextAudiogramDate.getMonth() + 3);
        }
      } catch (error) {
        console.error('Error fetching hearing report for reminder:', error.message);
      }
    }
    
    const audiogramExists = await reminderExists(appointment.id, 'AUDIOGRAM_DUE');
    if (!audiogramExists) {
      const reminder = await createReminder({
        client: client,
        title: `ƒêo th√≠nh l·ª±c ƒë·ªãnh k·ª≥ ti·∫øp theo - ${clientFullName}`,
        description: 'Nh·∫Øc nh·ªü ƒëo th√≠nh l·ª±c ƒë·ªãnh k·ª≥ ƒë·ªÉ theo d√µi t√¨nh tr·∫°ng th√≠nh gi√°c.',
        dueAt: nextAudiogramDate,
        status: nextAudiogramDate < new Date() ? 'overdue' : 'pending',
        type: 'AUDIOGRAM_DUE',
        priority: 'high',
        appointmentId: appointment,
        hearingReportId: hearingReport || undefined,
        isAutoGenerated: true,
        autoRecurring: true,
        recurringInterval: 180, // 6 th√°ng
        createdBy: createdBy,
        updatedBy: createdBy,
      });
      reminders.push(reminder);
    }

  } else if (appointmentType === 'COUNSELING') {
    // T∆∞ v·∫•n theo d√µi (3-6 th√°ng)
    const followUpDate = new Date(apptDate);
    followUpDate.setMonth(followUpDate.getMonth() + 3); // M·∫∑c ƒë·ªãnh 3 th√°ng
    
    const counselingExists = await reminderExists(appointment.id, 'FOLLOW_UP_COUNSELING');
    if (!counselingExists) {
      const reminder = await createReminder({
        client: client,
        title: `T∆∞ v·∫•n theo d√µi - ${clientFullName}`,
        description: 'Nh·∫Øc nh·ªü t∆∞ v·∫•n theo d√µi ƒë·ªÉ ƒë√°nh gi√° ti·∫øn tr√¨nh v√† h·ªó tr·ª£ kh√°ch h√†ng.',
        dueAt: followUpDate,
        status: followUpDate < new Date() ? 'overdue' : 'pending',
        type: 'FOLLOW_UP_COUNSELING',
        priority: 'medium',
        appointmentId: appointment,
        isAutoGenerated: true,
        autoRecurring: true,
        recurringInterval: 90, // 3 th√°ng
        createdBy: createdBy,
        updatedBy: createdBy,
      });
      reminders.push(reminder);
    }
  }

  return reminders;
}

/**
 * Create comprehensive reminders for a client (all types and statuses)
 */
async function createComprehensiveReminders(client, adminUser, appointments, hearingReports) {
  const now = new Date();
  const reminders = [];
  
  // Ensure client is properly fetched and get name
  try {
    await client.fetch({ useMasterKey: true });
  } catch (error) {
    console.error(`Error fetching client: ${error.message}`);
  }
  
  const clientName = client.get('fullName') || `${client.get('lastName')} ${client.get('firstName')}`;
  
  // Use client object directly - no need to create pointer
  
  // Helper to get date with offset
  const getDate = (daysOffset) => {
    const date = new Date(now);
    date.setDate(date.getDate() + daysOffset);
    return date;
  };
  
  // 1. Skip reminders from appointments for now (they're created automatically by Cloud Functions)
  // We'll focus on creating comprehensive test reminders with all types and statuses
  
  // 2. Additional test reminders with all types and statuses
  // Helper function to check if reminder exists by title
  const reminderExistsByTitle = async (title) => {
    try {
      const Reminder = Parse.Object.extend('Reminder');
      const query = new Parse.Query(Reminder);
      query.equalTo('client', client);
      query.equalTo('title', title);
      const count = await query.count({ useMasterKey: true });
      return count > 0;
    } catch (error) {
      console.error(`Error checking reminder existence: ${error.message}`);
      return false; // If check fails, allow creation
    }
  };
  
  // Helper to create reminder only if not exists
  const createReminderIfNotExists = async (data) => {
    try {
      const exists = await reminderExistsByTitle(data.title);
      if (!exists) {
        const reminder = await createReminder(data);
        reminders.push(reminder);
        console.log(`      ‚úÖ Created: ${data.title}`);
        return reminder;
      } else {
        console.log(`      ‚è≠Ô∏è  Skipped (exists): ${data.title}`);
      }
      return null;
    } catch (error) {
      console.error(`      ‚ùå Error creating reminder "${data.title}": ${error.message}`);
      return null;
    }
  };
  
  // OVERDUE reminders (qu√° h·∫°n)
  await createReminderIfNotExists({
    client: client,
    title: `[OVERDUE] ƒêo th√≠nh l·ª±c ƒë·ªãnh k·ª≥ - ${clientName}`,
    description: 'Reminder n√†y ƒë√£ qu√° h·∫°n ƒë·ªÉ test tr·∫°ng th√°i overdue.',
    dueAt: getDate(-30),
    status: 'overdue',
    type: 'AUDIOGRAM_DUE',
    priority: 'high',
    isAutoGenerated: false,
    createdBy: adminUser,
    updatedBy: adminUser,
  });
  
  await createReminderIfNotExists({
    client: client,
    title: `[OVERDUE] B·∫£o tr√¨ ƒë·ªãnh k·ª≥ - ${clientName}`,
    description: 'Nh·∫Øc nh·ªü b·∫£o tr√¨ ƒë√£ qu√° h·∫°n 15 ng√†y.',
    dueAt: getDate(-15),
    status: 'overdue',
    type: 'MAINTENANCE_DUE',
    priority: 'medium',
    isAutoGenerated: true,
    createdBy: adminUser,
    updatedBy: adminUser,
  });
  
  // PENDING - Today (h√¥m nay)
  await createReminderIfNotExists({
    client: client,
    title: `[TODAY] T∆∞ v·∫•n theo d√µi - ${clientName}`,
    description: 'Reminder ƒë·∫øn h·∫°n h√¥m nay ƒë·ªÉ test hi·ªÉn th·ªã.',
    dueAt: getDate(0),
    status: 'pending',
    type: 'FOLLOW_UP_COUNSELING',
    priority: 'high',
    isAutoGenerated: false,
    createdBy: adminUser,
    updatedBy: adminUser,
  });
  
  // PENDING - Tomorrow (ng√†y mai)
  await createReminderIfNotExists({
    client: client,
    title: `[TOMORROW] Ki·ªÉm tra sau s·ª≠a - ${clientName}`,
    description: 'Ki·ªÉm tra m√°y tr·ª£ th√≠nh v√†o ng√†y mai.',
    dueAt: getDate(1),
    status: 'pending',
    type: 'POST_REPAIR_CHECK',
    priority: 'high',
    isAutoGenerated: true,
    createdBy: adminUser,
    updatedBy: adminUser,
  });
  
  // PENDING - This week (tu·∫ßn n√†y)
  await createReminderIfNotExists({
    client: client,
    title: `[THIS WEEK] H·ªó tr·ª£ sau mua (1 tu·∫ßn) - ${clientName}`,
    description: 'H·ªó tr·ª£ kh√°ch h√†ng sau khi mua m√°y tr·ª£ th√≠nh.',
    dueAt: getDate(3),
    status: 'pending',
    type: 'POST_PURCHASE_SUPPORT',
    priority: 'high',
    isAutoGenerated: true,
    createdBy: adminUser,
    updatedBy: adminUser,
  });
  
  await createReminderIfNotExists({
    client: client,
    title: `[THIS WEEK] B·∫£o h√†nh s·∫Øp h·∫øt - ${clientName}`,
    description: 'B·∫£o h√†nh m√°y tr·ª£ th√≠nh s·∫Øp h·∫øt h·∫°n trong 5 ng√†y.',
    dueAt: getDate(5),
    status: 'pending',
    type: 'WARRANTY_EXPIRING',
    priority: 'medium',
    isAutoGenerated: false,
    createdBy: adminUser,
    updatedBy: adminUser,
  });
  
  // PENDING - Next week (tu·∫ßn sau)
  await createReminderIfNotExists({
    client: client,
    title: `[NEXT WEEK] Kh√°ch h√†ng l√¢u ch∆∞a ƒë·∫øn - ${clientName}`,
    description: 'Kh√°ch h√†ng ƒë√£ l√¢u ch∆∞a ƒë·∫øn kh√°m, c·∫ßn li√™n h·ªá.',
    dueAt: getDate(10),
    status: 'pending',
    type: 'CLIENT_INACTIVE',
    priority: 'low',
    isAutoGenerated: true,
    createdBy: adminUser,
    updatedBy: adminUser,
  });
  
  // PENDING - Next month (th√°ng sau)
  await createReminderIfNotExists({
    client: client,
    title: `[NEXT MONTH] ƒêo th√≠nh l·ª±c ƒë·ªãnh k·ª≥ - ${clientName}`,
    description: 'L·ªãch ƒëo th√≠nh l·ª±c ƒë·ªãnh k·ª≥ th√°ng sau.',
    dueAt: getDate(30),
    status: 'pending',
    type: 'AUDIOGRAM_DUE',
    priority: 'medium',
    isAutoGenerated: true,
    autoRecurring: true,
    recurringInterval: 180,
    createdBy: adminUser,
    updatedBy: adminUser,
  });
  
  await createReminderIfNotExists({
    client: client,
    title: `[NEXT MONTH] Sinh nh·∫≠t - ${clientName}`,
    description: 'Sinh nh·∫≠t kh√°ch h√†ng v√†o th√°ng sau.',
    dueAt: getDate(35),
    status: 'pending',
    type: 'BIRTHDAY',
    priority: 'low',
    isAutoGenerated: false,
    createdBy: adminUser,
    updatedBy: adminUser,
  });
  
  // DONE reminders (ƒë√£ ho√†n th√†nh)
  await createReminderIfNotExists({
    client: client,
    title: `[DONE] H·ªó tr·ª£ sau mua (1 th√°ng) - ${clientName}`,
    description: 'ƒê√£ ho√†n th√†nh h·ªó tr·ª£ sau mua 1 th√°ng.',
    dueAt: getDate(-60),
    status: 'done',
    type: 'POST_PURCHASE_SUPPORT',
    priority: 'medium',
    isAutoGenerated: true,
    createdBy: adminUser,
    updatedBy: adminUser,
  });
  
  await createReminderIfNotExists({
    client: client,
    title: `[DONE] T∆∞ v·∫•n theo d√µi - ${clientName}`,
    description: 'ƒê√£ ho√†n th√†nh t∆∞ v·∫•n theo d√µi.',
    dueAt: getDate(-90),
    status: 'done',
    type: 'FOLLOW_UP_COUNSELING',
    priority: 'low',
    isAutoGenerated: true,
    createdBy: adminUser,
    updatedBy: adminUser,
  });
  
  // CUSTOM reminder
  await createReminderIfNotExists({
    client: client,
    title: `[CUSTOM] Nh·∫Øc nh·ªü t√πy ch·ªânh - ${clientName}`,
    description: 'ƒê√¢y l√† reminder t√πy ch·ªânh do nh√¢n vi√™n t·∫°o.',
    dueAt: getDate(7),
    status: 'pending',
    type: 'CUSTOM',
    priority: 'medium',
    isAutoGenerated: false,
    createdBy: adminUser,
    updatedBy: adminUser,
  });
  
  // RECOMMENDATION_FOLLOW_UP
  if (hearingReports && hearingReports.length > 0) {
    const reportId = hearingReports[0].id || hearingReports[0].objectId;
    if (reportId) {
      await createReminderIfNotExists({
        client: client,
        title: `[RECOMMENDATION] Theo d√µi khuy·∫øn ngh·ªã - ${clientName}`,
        description: 'Theo d√µi vi·ªác th·ª±c hi·ªán c√°c khuy·∫øn ngh·ªã t·ª´ b√°o c√°o th√≠nh l·ª±c.',
        dueAt: getDate(14),
        status: 'pending',
        type: 'RECOMMENDATION_FOLLOW_UP',
        priority: 'medium',
        hearingReportId: Parse.Object.createWithoutData('HearingReport', reportId),
        isAutoGenerated: false,
        createdBy: adminUser,
        updatedBy: adminUser,
      });
    }
  }
  
  return reminders;
}

/**
 * Main seed function
 */
async function seedRemindersForSampleUsers() {
  console.log('\nüöÄ Starting to seed comprehensive reminders for sample users...');
  console.log(`üì° Connecting to Parse Server: ${SERVER_URL}\n`);
  
  // Get admin user
  const AdminUser = Parse.Object.extend('_User');
  const adminQuery = new Parse.Query(AdminUser);
  adminQuery.equalTo('username', 'admin');
  const adminUser = await adminQuery.first({ useMasterKey: true });
  
  if (!adminUser) {
    console.warn('‚ö†Ô∏è  Admin user not found, reminders will be created without createdBy');
  }
  
  // Find all clients with lastName "M·∫´u"
  const Client = Parse.Object.extend('Client');
  const clientQuery = new Parse.Query(Client);
  clientQuery.equalTo('lastName', 'M·∫´u');
  const sampleClients = await clientQuery.find({ useMasterKey: true });
  
  if (sampleClients.length === 0) {
    console.log('‚ö†Ô∏è  No sample clients found with lastName "M·∫´u"');
    console.log('   Please run seedSampleUsers.js first to create sample clients.');
    return;
  }
  
  console.log(`‚úÖ Found ${sampleClients.length} sample client(s)\n`);
  
  let totalReminders = 0;
  let totalAppointments = 0;
  const statusCounts = { pending: 0, overdue: 0, done: 0 };
  const typeCounts = {};
  const priorityCounts = { low: 0, medium: 0, high: 0 };
  
  // Process each sample client
  for (const client of sampleClients) {
    const clientName = client.get('fullName') || `${client.get('lastName')} ${client.get('firstName')}`;
    console.log(`üìã Processing: ${clientName}`);
    
    try {
      // Find all COMPLETED appointments for this client
      const Appointment = Parse.Object.extend('Appointment');
      const appointmentQuery = new Parse.Query(Appointment);
      appointmentQuery.equalTo('client', client);
      appointmentQuery.equalTo('status', 'COMPLETED');
      appointmentQuery.include('hearingReport');
      const appointments = await appointmentQuery.find({ useMasterKey: true });
      
      // Find hearing reports for this client
      const HearingReport = Parse.Object.extend('HearingReport');
      const reportQuery = new Parse.Query(HearingReport);
      reportQuery.equalTo('client', client);
      reportQuery.limit(5);
      const hearingReports = await reportQuery.find({ useMasterKey: true });
      
      console.log(`   Found ${appointments.length} completed appointment(s)`);
      console.log(`   Found ${hearingReports.length} hearing report(s)`);
      totalAppointments += appointments.length;
      
      // Create comprehensive reminders
      const reminders = await createComprehensiveReminders(
        client,
        adminUser,
        appointments,
        hearingReports
      );
      
      // Count statistics
      reminders.forEach(reminder => {
        const status = reminder.get('status') || 'pending';
        const type = reminder.get('type') || 'CUSTOM';
        const priority = reminder.get('priority') || 'medium';
        
        statusCounts[status] = (statusCounts[status] || 0) + 1;
        typeCounts[type] = (typeCounts[type] || 0) + 1;
        priorityCounts[priority] = (priorityCounts[priority] || 0) + 1;
      });
      
      totalReminders += reminders.length;
      console.log(`   ‚úÖ Created ${reminders.length} reminder(s)\n`);
      
    } catch (error) {
      console.error(`   ‚ùå Error processing ${clientName}:`, error.message);
      console.error(error.stack);
    }
  }
  
  // Summary
  console.log('\n' + '='.repeat(60));
  console.log('üìä SEED SUMMARY');
  console.log('='.repeat(60));
  console.log(`   ‚úÖ Sample Clients: ${sampleClients.length}`);
  console.log(`   ‚úÖ Processed Appointments: ${totalAppointments}`);
  console.log(`   ‚úÖ Total Reminders Created: ${totalReminders}`);
  console.log('\n   üìà By Status:');
  console.log(`      - Pending: ${statusCounts.pending || 0}`);
  console.log(`      - Overdue: ${statusCounts.overdue || 0}`);
  console.log(`      - Done: ${statusCounts.done || 0}`);
  console.log('\n   üìà By Priority:');
  console.log(`      - High: ${priorityCounts.high || 0}`);
  console.log(`      - Medium: ${priorityCounts.medium || 0}`);
  console.log(`      - Low: ${priorityCounts.low || 0}`);
  console.log('\n   üìà By Type:');
  Object.entries(typeCounts).forEach(([type, count]) => {
    console.log(`      - ${type}: ${count}`);
  });
  console.log('='.repeat(60));
  console.log('\n‚ú® Comprehensive reminders seed completed successfully!');
  console.log('üéØ You now have reminders with all types and statuses for testing.\n');
}

// Run the seed function
seedRemindersForSampleUsers()
  .then(() => {
    process.exit(0);
  })
  .catch((error) => {
    console.error('\n‚ùå Fatal error:', error);
    console.error('Stack trace:', error.stack);
    process.exit(1);
  });

