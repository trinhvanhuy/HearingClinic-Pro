const Parse = require('parse/node');
require('dotenv').config();

// Parse Server Configuration
const APP_ID = process.env.PARSE_APP_ID || 'hearing-clinic-app-id';
const MASTER_KEY = process.env.PARSE_MASTER_KEY || 'your-master-key-change-this';
const DATABASE_URI = process.env.DATABASE_URI || 'mongodb://mongo:27017/hearing-clinic-db';
const isInsideDocker = require('fs').existsSync('/.dockerenv');
const SERVER_URL = process.env.PARSE_SERVER_URL || 
  (isInsideDocker ? 'http://localhost:1337/parse' : 'http://localhost:1338/parse');

// Initialize Parse
Parse.initialize(APP_ID);
Parse.serverURL = SERVER_URL;
Parse.masterKey = MASTER_KEY;

/**
 * Helper function to create a reminder
 */
async function createReminder(data) {
  const Reminder = Parse.Object.extend('Reminder');
  const reminder = new Reminder();
  
  reminder.set('client', data.client);
  reminder.set('title', data.title);
  if (data.description) reminder.set('description', data.description);
  reminder.set('dueAt', data.dueAt);
  reminder.set('status', data.status || 'pending');
  if (data.type) reminder.set('type', data.type);
  if (data.priority) reminder.set('priority', data.priority);
  if (data.appointmentId) reminder.set('appointmentId', data.appointmentId);
  if (data.hearingReportId) reminder.set('hearingReportId', data.hearingReportId);
  if (data.isAutoGenerated !== undefined) reminder.set('isAutoGenerated', data.isAutoGenerated);
  if (data.autoRecurring !== undefined) reminder.set('autoRecurring', data.autoRecurring);
  if (data.recurringInterval) reminder.set('recurringInterval', data.recurringInterval);
  if (data.createdBy) reminder.set('createdBy', data.createdBy);
  if (data.updatedBy) reminder.set('updatedBy', data.updatedBy);
  
  return await reminder.save(null, { useMasterKey: true });
}

/**
 * Check if reminder already exists for this appointment and type
 */
async function reminderExists(appointmentId, type) {
  const Reminder = Parse.Object.extend('Reminder');
  const query = new Parse.Query(Reminder);
  query.equalTo('appointmentId', Parse.Object.createWithoutData('Appointment', appointmentId));
  query.equalTo('type', type);
  const count = await query.count({ useMasterKey: true });
  return count > 0;
}

/**
 * Create reminders for a completed appointment
 */
async function createRemindersForAppointment(appointment, adminUser) {
  const appointmentType = appointment.get('type');
  const status = appointment.get('status');
  const appointmentDate = appointment.get('date');
  const client = appointment.get('client');
  const createdBy = appointment.get('createdBy') || adminUser;

  // Only create reminders for COMPLETED appointments
  if (status !== 'COMPLETED' || !client || !appointmentDate) {
    return [];
  }

  const reminders = [];
  const apptDate = new Date(appointmentDate);
  const clientId = typeof client === 'object' ? client.id : client;
  
  // Fetch client to get fullName
  let clientFullName = '';
  if (typeof client === 'object' && client.id) {
    try {
      await client.fetch({ useMasterKey: true });
      clientFullName = client.get('fullName') || '';
    } catch (error) {
      console.error(`Error fetching client for reminder: ${error.message}`);
    }
  }
  const clientPointer = Parse.Object.createWithoutData('Client', clientId);

  if (appointmentType === 'REPAIR') {
    // 1. Ki·ªÉm tra sau s·ª≠a (2 tu·∫ßn)
    const checkupDate = new Date(apptDate);
    checkupDate.setDate(checkupDate.getDate() + 14);
    
    const checkupExists = await reminderExists(appointment.id, 'POST_REPAIR_CHECK');
    if (!checkupExists) {
      const reminder = await createReminder({
        client: clientPointer,
        title: `Ki·ªÉm tra sau s·ª≠a m√°y - ${clientFullName}`,
        description: 'Ki·ªÉm tra m√°y tr·ª£ th√≠nh sau khi s·ª≠a ƒë·ªÉ ƒë·∫£m b·∫£o ho·∫°t ƒë·ªông t·ªët.',
        dueAt: checkupDate,
        status: checkupDate < new Date() ? 'overdue' : 'pending',
        type: 'POST_REPAIR_CHECK',
        priority: 'medium',
        appointmentId: appointment,
        isAutoGenerated: true,
        createdBy: createdBy,
        updatedBy: createdBy,
      });
      reminders.push(reminder);
    }

    // 2. B·∫£o tr√¨ ƒë·ªãnh k·ª≥ (6 th√°ng)
    const maintenanceDate = new Date(apptDate);
    maintenanceDate.setMonth(maintenanceDate.getMonth() + 6);
    
    const maintenanceExists = await reminderExists(appointment.id, 'MAINTENANCE_DUE');
    if (!maintenanceExists) {
      const reminder = await createReminder({
        client: clientPointer,
        title: `B·∫£o tr√¨ ƒë·ªãnh k·ª≥ m√°y tr·ª£ th√≠nh - ${clientFullName}`,
        description: 'Nh·∫Øc nh·ªü b·∫£o tr√¨ ƒë·ªãnh k·ª≥ m√°y tr·ª£ th√≠nh sau 6 th√°ng.',
        dueAt: maintenanceDate,
        status: maintenanceDate < new Date() ? 'overdue' : 'pending',
        type: 'MAINTENANCE_DUE',
        priority: 'medium',
        appointmentId: appointment,
        isAutoGenerated: true,
        autoRecurring: true,
        recurringInterval: 180, // 6 th√°ng
        createdBy: createdBy,
        updatedBy: createdBy,
      });
      reminders.push(reminder);
    }

  } else if (appointmentType === 'PURCHASE') {
    // H·ªó tr·ª£ sau mua: 1 tu·∫ßn, 1 th√°ng, 3 th√°ng
    const intervals = [
      { days: 7, title: 'H·ªó tr·ª£ sau mua (1 tu·∫ßn)', description: 'Li√™n h·ªá kh√°ch h√†ng sau 1 tu·∫ßn ƒë·ªÉ h·ªó tr·ª£ v√† ƒëi·ªÅu ch·ªânh m√°y tr·ª£ th√≠nh.', type: 'POST_PURCHASE_SUPPORT' },
      { days: 30, title: 'H·ªó tr·ª£ sau mua (1 th√°ng)', description: 'Theo d√µi t√¨nh tr·∫°ng s·ª≠ d·ª•ng m√°y tr·ª£ th√≠nh sau 1 th√°ng.', type: 'POST_PURCHASE_SUPPORT' },
      { days: 90, title: 'H·ªó tr·ª£ sau mua (3 th√°ng)', description: 'ƒê√°nh gi√° hi·ªáu qu·∫£ s·ª≠ d·ª•ng m√°y tr·ª£ th√≠nh sau 3 th√°ng.', type: 'POST_PURCHASE_SUPPORT' },
    ];

    for (const interval of intervals) {
      const dueDate = new Date(apptDate);
      dueDate.setDate(dueDate.getDate() + interval.days);
      
      // Check if reminder already exists (we'll use a combination of type and days)
      const existingQuery = new Parse.Query(Parse.Object.extend('Reminder'));
      existingQuery.equalTo('appointmentId', appointment);
      existingQuery.equalTo('type', interval.type);
      existingQuery.equalTo('title', `${interval.title} - ${clientFullName}`);
      const exists = await existingQuery.count({ useMasterKey: true }) > 0;
      
      if (!exists) {
        const reminder = await createReminder({
          client: clientPointer,
          title: `${interval.title} - ${clientFullName}`,
          description: interval.description,
          dueAt: dueDate,
          status: dueDate < new Date() ? 'overdue' : 'pending',
          type: interval.type,
          priority: interval.days === 7 ? 'high' : 'medium',
          appointmentId: appointment,
          isAutoGenerated: true,
          createdBy: createdBy,
          updatedBy: createdBy,
        });
        reminders.push(reminder);
      }
    }

  } else if (appointmentType === 'AUDIOGRAM') {
    // ƒêo th√≠nh l·ª±c ƒë·ªãnh k·ª≥ ti·∫øp theo (6-12 th√°ng)
    const hearingReport = appointment.get('hearingReport');
    let nextAudiogramDate = new Date(apptDate);
    nextAudiogramDate.setMonth(nextAudiogramDate.getMonth() + 6); // M·∫∑c ƒë·ªãnh 6 th√°ng
    
    // C√≥ th·ªÉ ƒëi·ªÅu ch·ªânh d·ª±a tr√™n recommendations trong hearing report
    if (hearingReport) {
      try {
        await hearingReport.fetch({ useMasterKey: true });
        const recommendations = hearingReport.get('recommendations');
        if (recommendations && recommendations.toLowerCase().includes('3 th√°ng')) {
          nextAudiogramDate = new Date(apptDate);
          nextAudiogramDate.setMonth(nextAudiogramDate.getMonth() + 3);
        }
      } catch (error) {
        console.error('Error fetching hearing report for reminder:', error.message);
      }
    }
    
    const audiogramExists = await reminderExists(appointment.id, 'AUDIOGRAM_DUE');
    if (!audiogramExists) {
      const reminder = await createReminder({
        client: clientPointer,
        title: `ƒêo th√≠nh l·ª±c ƒë·ªãnh k·ª≥ ti·∫øp theo - ${clientFullName}`,
        description: 'Nh·∫Øc nh·ªü ƒëo th√≠nh l·ª±c ƒë·ªãnh k·ª≥ ƒë·ªÉ theo d√µi t√¨nh tr·∫°ng th√≠nh gi√°c.',
        dueAt: nextAudiogramDate,
        status: nextAudiogramDate < new Date() ? 'overdue' : 'pending',
        type: 'AUDIOGRAM_DUE',
        priority: 'high',
        appointmentId: appointment,
        hearingReportId: hearingReport || undefined,
        isAutoGenerated: true,
        autoRecurring: true,
        recurringInterval: 180, // 6 th√°ng
        createdBy: createdBy,
        updatedBy: createdBy,
      });
      reminders.push(reminder);
    }

  } else if (appointmentType === 'COUNSELING') {
    // T∆∞ v·∫•n theo d√µi (3-6 th√°ng)
    const followUpDate = new Date(apptDate);
    followUpDate.setMonth(followUpDate.getMonth() + 3); // M·∫∑c ƒë·ªãnh 3 th√°ng
    
    const counselingExists = await reminderExists(appointment.id, 'FOLLOW_UP_COUNSELING');
    if (!counselingExists) {
      const reminder = await createReminder({
        client: clientPointer,
        title: `T∆∞ v·∫•n theo d√µi - ${clientFullName}`,
        description: 'Nh·∫Øc nh·ªü t∆∞ v·∫•n theo d√µi ƒë·ªÉ ƒë√°nh gi√° ti·∫øn tr√¨nh v√† h·ªó tr·ª£ kh√°ch h√†ng.',
        dueAt: followUpDate,
        status: followUpDate < new Date() ? 'overdue' : 'pending',
        type: 'FOLLOW_UP_COUNSELING',
        priority: 'medium',
        appointmentId: appointment,
        isAutoGenerated: true,
        autoRecurring: true,
        recurringInterval: 90, // 3 th√°ng
        createdBy: createdBy,
        updatedBy: createdBy,
      });
      reminders.push(reminder);
    }
  }

  return reminders;
}

/**
 * Main seed function
 */
async function seedRemindersForSampleUsers() {
  console.log('\nüöÄ Starting to seed reminders for sample users...');
  console.log(`üì° Connecting to Parse Server: ${SERVER_URL}\n`);
  
  // Get admin user
  const AdminUser = Parse.Object.extend('_User');
  const adminQuery = new Parse.Query(AdminUser);
  adminQuery.equalTo('username', 'admin');
  const adminUser = await adminQuery.first({ useMasterKey: true });
  
  if (!adminUser) {
    console.warn('‚ö†Ô∏è  Admin user not found, reminders will be created without createdBy');
  }
  
  // Find all clients with lastName "M·∫´u"
  const Client = Parse.Object.extend('Client');
  const clientQuery = new Parse.Query(Client);
  clientQuery.equalTo('lastName', 'M·∫´u');
  const sampleClients = await clientQuery.find({ useMasterKey: true });
  
  if (sampleClients.length === 0) {
    console.log('‚ö†Ô∏è  No sample clients found with lastName "M·∫´u"');
    console.log('   Please run seedSampleUsers.js first to create sample clients.');
    return;
  }
  
  console.log(`‚úÖ Found ${sampleClients.length} sample client(s)\n`);
  
  let totalReminders = 0;
  let totalAppointments = 0;
  
  // Process each sample client
  for (const client of sampleClients) {
    const clientName = client.get('fullName') || `${client.get('lastName')} ${client.get('firstName')}`;
    console.log(`üìã Processing: ${clientName}`);
    
    try {
      // Find all COMPLETED appointments for this client
      const Appointment = Parse.Object.extend('Appointment');
      const appointmentQuery = new Parse.Query(Appointment);
      appointmentQuery.equalTo('client', client);
      appointmentQuery.equalTo('status', 'COMPLETED');
      appointmentQuery.include('hearingReport');
      const appointments = await appointmentQuery.find({ useMasterKey: true });
      
      console.log(`   Found ${appointments.length} completed appointment(s)`);
      totalAppointments += appointments.length;
      
      if (appointments.length === 0) {
        console.log(`   ‚è≠Ô∏è  No completed appointments found, skipping...\n`);
        continue;
      }
      
      // Create reminders for each appointment
      let clientReminders = 0;
      for (const appointment of appointments) {
        const reminders = await createRemindersForAppointment(appointment, adminUser);
        clientReminders += reminders.length;
        totalReminders += reminders.length;
      }
      
      console.log(`   ‚úÖ Created ${clientReminders} reminder(s)\n`);
      
    } catch (error) {
      console.error(`   ‚ùå Error processing ${clientName}:`, error.message);
    }
  }
  
  // Summary
  console.log('\n' + '='.repeat(60));
  console.log('üìä SEED SUMMARY');
  console.log('='.repeat(60));
  console.log(`   ‚úÖ Sample Clients: ${sampleClients.length}`);
  console.log(`   ‚úÖ Processed Appointments: ${totalAppointments}`);
  console.log(`   ‚úÖ Reminders Created: ${totalReminders}`);
  console.log('='.repeat(60));
  console.log('\n‚ú® Reminders seed completed successfully!\n');
}

// Run the seed function
seedRemindersForSampleUsers()
  .then(() => {
    process.exit(0);
  })
  .catch((error) => {
    console.error('\n‚ùå Fatal error:', error);
    console.error('Stack trace:', error.stack);
    process.exit(1);
  });

