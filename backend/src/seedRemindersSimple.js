const Parse = require('parse/node');
require('dotenv').config();

// Parse Server Configuration
const APP_ID = process.env.PARSE_APP_ID || 'hearing-clinic-app-id';
const MASTER_KEY = process.env.PARSE_MASTER_KEY || 'your-master-key-change-this';
const isInsideDocker = require('fs').existsSync('/.dockerenv');
const SERVER_URL = process.env.PARSE_SERVER_URL || 
  (isInsideDocker ? 'http://localhost:1337/parse' : 'http://localhost:1338/parse');

// Initialize Parse
Parse.initialize(APP_ID);
Parse.serverURL = SERVER_URL;
Parse.masterKey = MASTER_KEY;

/**
 * Helper function to create a reminder - simple version
 */
async function createReminder(client, title, description, dueAt, status, type, priority, adminUser) {
  try {
    const Reminder = Parse.Object.extend('Reminder');
    const reminder = new Reminder();
    
    // Use client object directly (already fetched)
    reminder.set('client', client);
    reminder.set('title', title);
    if (description) reminder.set('description', description);
    reminder.set('dueAt', dueAt);
    reminder.set('status', status);
    if (type) reminder.set('type', type);
    if (priority) reminder.set('priority', priority);
    if (adminUser) {
      reminder.set('createdBy', adminUser);
      reminder.set('updatedBy', adminUser);
    }
    
    return await reminder.save(null, { useMasterKey: true });
  } catch (error) {
    console.error(`      ‚ùå Error creating "${title}": ${error.message}`);
    return null;
  }
}

/**
 * Check if reminder with same title exists for client
 */
async function reminderExists(client, title) {
  try {
    const Reminder = Parse.Object.extend('Reminder');
    const query = new Parse.Query(Reminder);
    query.equalTo('client', client);
    query.equalTo('title', title);
    const count = await query.count({ useMasterKey: true });
    return count > 0;
  } catch (error) {
    return false;
  }
}

/**
 * Create comprehensive test reminders for a client
 */
async function createTestRemindersForClient(client, adminUser) {
  const now = new Date();
  const clientName = client.get('fullName') || `${client.get('lastName')} ${client.get('firstName')}`;
  const reminders = [];
  
  // Helper to get date with offset
  const getDate = (daysOffset) => {
    const date = new Date(now);
    date.setDate(date.getDate() + daysOffset);
    return date;
  };
  
  // Helper to create reminder only if not exists
  const createIfNotExists = async (title, description, dueAt, status, type, priority, isAuto = false) => {
    const exists = await reminderExists(client, title);
    if (!exists) {
      const reminder = await createReminder(client, title, description, dueAt, status, type, priority, adminUser);
      if (reminder) {
        if (isAuto) reminder.set('isAutoGenerated', true);
        await reminder.save(null, { useMasterKey: true });
        reminders.push(reminder);
        console.log(`      ‚úÖ Created: ${title}`);
        return reminder;
      }
    } else {
      console.log(`      ‚è≠Ô∏è  Skipped (exists): ${title}`);
    }
    return null;
  };
  
  console.log(`   üìù Creating test reminders for: ${clientName}`);
  
  // OVERDUE reminders
  await createIfNotExists(
    `[OVERDUE] ƒêo th√≠nh l·ª±c ƒë·ªãnh k·ª≥ - ${clientName}`,
    'Reminder n√†y ƒë√£ qu√° h·∫°n ƒë·ªÉ test tr·∫°ng th√°i overdue.',
    getDate(-30),
    'overdue',
    'AUDIOGRAM_DUE',
    'high',
    false
  );
  
  await createIfNotExists(
    `[OVERDUE] B·∫£o tr√¨ ƒë·ªãnh k·ª≥ - ${clientName}`,
    'Nh·∫Øc nh·ªü b·∫£o tr√¨ ƒë√£ qu√° h·∫°n 15 ng√†y.',
    getDate(-15),
    'overdue',
    'MAINTENANCE_DUE',
    'medium',
    true
  );
  
  // PENDING - Today
  await createIfNotExists(
    `[TODAY] T∆∞ v·∫•n theo d√µi - ${clientName}`,
    'Reminder ƒë·∫øn h·∫°n h√¥m nay ƒë·ªÉ test hi·ªÉn th·ªã.',
    getDate(0),
    'pending',
    'FOLLOW_UP_COUNSELING',
    'high',
    false
  );
  
  // PENDING - Tomorrow
  await createIfNotExists(
    `[TOMORROW] Ki·ªÉm tra sau s·ª≠a - ${clientName}`,
    'Ki·ªÉm tra m√°y tr·ª£ th√≠nh v√†o ng√†y mai.',
    getDate(1),
    'pending',
    'POST_REPAIR_CHECK',
    'high',
    true
  );
  
  // PENDING - This week
  await createIfNotExists(
    `[THIS WEEK] H·ªó tr·ª£ sau mua (1 tu·∫ßn) - ${clientName}`,
    'H·ªó tr·ª£ kh√°ch h√†ng sau khi mua m√°y tr·ª£ th√≠nh.',
    getDate(3),
    'pending',
    'POST_PURCHASE_SUPPORT',
    'high',
    true
  );
  
  await createIfNotExists(
    `[THIS WEEK] B·∫£o h√†nh s·∫Øp h·∫øt - ${clientName}`,
    'B·∫£o h√†nh m√°y tr·ª£ th√≠nh s·∫Øp h·∫øt h·∫°n trong 5 ng√†y.',
    getDate(5),
    'pending',
    'WARRANTY_EXPIRING',
    'medium',
    false
  );
  
  // PENDING - Next week
  await createIfNotExists(
    `[NEXT WEEK] Kh√°ch h√†ng l√¢u ch∆∞a ƒë·∫øn - ${clientName}`,
    'Kh√°ch h√†ng ƒë√£ l√¢u ch∆∞a ƒë·∫øn kh√°m, c·∫ßn li√™n h·ªá.',
    getDate(10),
    'pending',
    'CLIENT_INACTIVE',
    'low',
    true
  );
  
  // PENDING - Next month
  await createIfNotExists(
    `[NEXT MONTH] ƒêo th√≠nh l·ª±c ƒë·ªãnh k·ª≥ - ${clientName}`,
    'L·ªãch ƒëo th√≠nh l·ª±c ƒë·ªãnh k·ª≥ th√°ng sau.',
    getDate(30),
    'pending',
    'AUDIOGRAM_DUE',
    'medium',
    true
  );
  
  await createIfNotExists(
    `[NEXT MONTH] Sinh nh·∫≠t - ${clientName}`,
    'Sinh nh·∫≠t kh√°ch h√†ng v√†o th√°ng sau.',
    getDate(35),
    'pending',
    'BIRTHDAY',
    'low',
    false
  );
  
  // DONE reminders
  await createIfNotExists(
    `[DONE] H·ªó tr·ª£ sau mua (1 th√°ng) - ${clientName}`,
    'ƒê√£ ho√†n th√†nh h·ªó tr·ª£ sau mua 1 th√°ng.',
    getDate(-60),
    'done',
    'POST_PURCHASE_SUPPORT',
    'medium',
    true
  );
  
  await createIfNotExists(
    `[DONE] T∆∞ v·∫•n theo d√µi - ${clientName}`,
    'ƒê√£ ho√†n th√†nh t∆∞ v·∫•n theo d√µi.',
    getDate(-90),
    'done',
    'FOLLOW_UP_COUNSELING',
    'low',
    true
  );
  
  // CUSTOM reminder
  await createIfNotExists(
    `[CUSTOM] Nh·∫Øc nh·ªü t√πy ch·ªânh - ${clientName}`,
    'ƒê√¢y l√† reminder t√πy ch·ªânh do nh√¢n vi√™n t·∫°o.',
    getDate(7),
    'pending',
    'CUSTOM',
    'medium',
    false
  );
  
  return reminders;
}

/**
 * Main seed function
 */
async function seedRemindersSimple() {
  console.log('\nüöÄ Starting to seed reminders (simple version)...');
  console.log(`üì° Connecting to Parse Server: ${SERVER_URL}\n`);
  
  // Get admin user
  const AdminUser = Parse.Object.extend('_User');
  const adminQuery = new Parse.Query(AdminUser);
  adminQuery.equalTo('username', 'admin');
  const adminUser = await adminQuery.first({ useMasterKey: true });
  
  if (!adminUser) {
    console.warn('‚ö†Ô∏è  Admin user not found, reminders will be created without createdBy');
  } else {
    console.log(`‚úÖ Found admin user: ${adminUser.get('username')}`);
  }
  
  // Find all clients with lastName "M·∫´u"
  const Client = Parse.Object.extend('Client');
  const clientQuery = new Parse.Query(Client);
  clientQuery.equalTo('lastName', 'M·∫´u');
  const sampleClients = await clientQuery.find({ useMasterKey: true });
  
  if (sampleClients.length === 0) {
    console.log('‚ö†Ô∏è  No sample clients found with lastName "M·∫´u"');
    console.log('   Please run seedSampleUsers.js first to create sample clients.');
    return;
  }
  
  console.log(`‚úÖ Found ${sampleClients.length} sample client(s)\n`);
  
  let totalReminders = 0;
  const statusCounts = { pending: 0, overdue: 0, done: 0 };
  const typeCounts = {};
  const priorityCounts = { low: 0, medium: 0, high: 0 };
  
  // Process each sample client
  for (const client of sampleClients) {
    try {
      // Ensure client is fetched
      await client.fetch({ useMasterKey: true });
      
      const reminders = await createTestRemindersForClient(client, adminUser);
      totalReminders += reminders.length;
      
      // Count statistics
      reminders.forEach(reminder => {
        const status = reminder.get('status') || 'pending';
        const type = reminder.get('type') || 'CUSTOM';
        const priority = reminder.get('priority') || 'medium';
        
        statusCounts[status] = (statusCounts[status] || 0) + 1;
        typeCounts[type] = (typeCounts[type] || 0) + 1;
        priorityCounts[priority] = (priorityCounts[priority] || 0) + 1;
      });
      
      console.log(`   ‚úÖ Created ${reminders.length} reminder(s) for ${client.get('fullName')}\n`);
      
    } catch (error) {
      console.error(`   ‚ùå Error processing ${client.get('fullName')}:`, error.message);
    }
  }
  
  // Summary
  console.log('\n' + '='.repeat(60));
  console.log('üìä SEED SUMMARY');
  console.log('='.repeat(60));
  console.log(`   ‚úÖ Sample Clients: ${sampleClients.length}`);
  console.log(`   ‚úÖ Total Reminders Created: ${totalReminders}`);
  console.log('\n   üìà By Status:');
  console.log(`      - Pending: ${statusCounts.pending || 0}`);
  console.log(`      - Overdue: ${statusCounts.overdue || 0}`);
  console.log(`      - Done: ${statusCounts.done || 0}`);
  console.log('\n   üìà By Priority:');
  console.log(`      - High: ${priorityCounts.high || 0}`);
  console.log(`      - Medium: ${priorityCounts.medium || 0}`);
  console.log(`      - Low: ${priorityCounts.low || 0}`);
  console.log('\n   üìà By Type:');
  Object.entries(typeCounts).forEach(([type, count]) => {
    console.log(`      - ${type}: ${count}`);
  });
  console.log('='.repeat(60));
  console.log('\n‚ú® Reminders seed completed successfully!');
  console.log('üéØ You now have reminders with all types and statuses for testing.\n');
}

// Run the seed function
seedRemindersSimple()
  .then(() => {
    process.exit(0);
  })
  .catch((error) => {
    console.error('\n‚ùå Fatal error:', error);
    console.error('Stack trace:', error.stack);
    process.exit(1);
  });

